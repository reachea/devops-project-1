---
- name: Create infrastructure on DigitalOcean
  hosts: localhost
  connection: local
  gather_facts: false
  vars_files:
    - group_vars/all.yml

  tasks:
    - name: Sanity check required vars
      ansible.builtin.assert:
        that:
          - do_token is defined
          - region is defined
          - image is defined
          - ssh_key_id is defined
        fail_msg: "Missing one of: do_token, region, image, ssh_key_id. Check group_vars/all.yml and env DO_TOKEN."

    # -------------------------
    # Create droplets
    # -------------------------
    - name: Create Jenkins droplet
      community.digitalocean.digital_ocean_droplet:
        state: present
        name: "{{ jenkins_name }}"
        oauth_token: "{{ do_token }}"
        region: "{{ region }}"
        size: "{{ size_small }}"
        image: "{{ image }}"
        ssh_keys: ["{{ ssh_key_id }}"]
        monitoring: true
        backups: false
        ipv6: false
        tags: ["devops", "jenkins"]
      register: jenkins

    - name: Create SonarQube droplet
      community.digitalocean.digital_ocean_droplet:
        state: present
        name: "{{ sonarqube_name }}"
        oauth_token: "{{ do_token }}"
        region: "{{ region }}"
        size: "{{ size_small }}"
        image: "{{ image }}"
        ssh_keys: ["{{ ssh_key_id }}"]
        monitoring: true
        backups: false
        ipv6: false
        tags: ["devops", "sonarqube"]
      register: sonarqube

    - name: Create Nexus droplet
      community.digitalocean.digital_ocean_droplet:
        state: present
        name: "{{ nexus_name }}"
        oauth_token: "{{ do_token }}"
        region: "{{ region }}"
        size: "{{ size_small }}"
        image: "{{ image }}"
        ssh_keys: ["{{ ssh_key_id }}"]
        monitoring: true
        backups: false
        ipv6: false
        tags: ["devops", "nexus"]
      register: nexus

    # -------------------------
    # Query droplets & compute IPs (version-proof)
    # -------------------------
    - name: Get Jenkins droplet info
      community.digitalocean.digital_ocean_droplet_info:
        oauth_token: "{{ do_token }}"
        name: "{{ jenkins_name }}"
      register: jenkins_info

    - name: Get SonarQube droplet info
      community.digitalocean.digital_ocean_droplet_info:
        oauth_token: "{{ do_token }}"
        name: "{{ sonarqube_name }}"
      register: sonarqube_info

    - name: Get Nexus droplet info
      community.digitalocean.digital_ocean_droplet_info:
        oauth_token: "{{ do_token }}"
        name: "{{ nexus_name }}"
      register: nexus_info

    - name: Normalize droplet objects
      set_fact:
        jenkins_obj: >-
          {{
            (jenkins_info.data | default([]))
            | selectattr('name','equalto', jenkins_name)
            | list | first | default(
              (jenkins_info.droplets | default([]))
              | selectattr('name','equalto', jenkins_name)
              | list | first
            )
          }}
        sonarqube_obj: >-
          {{
            (sonarqube_info.data | default([]))
            | selectattr('name','equalto', sonarqube_name)
            | list | first | default(
              (sonarqube_info.droplets | default([]))
              | selectattr('name','equalto', sonarqube_name)
              | list | first
            )
          }}
        nexus_obj: >-
          {{
            (nexus_info.data | default([]))
            | selectattr('name','equalto', nexus_name)
            | list | first | default(
              (nexus_info.droplets | default([]))
              | selectattr('name','equalto', nexus_name)
              | list | first
            )
          }}

    - name: Compute public IPv4s
      set_fact:
        jenkins_ip: >-
          {{ (jenkins_obj.networks.v4
              | selectattr('type','equalto','public')
              | map(attribute='ip_address')
              | list | first) | default('') }}
        sonarqube_ip: >-
          {{ (sonarqube_obj.networks.v4
              | selectattr('type','equalto','public')
              | map(attribute='ip_address')
              | list | first) | default('') }}
        nexus_ip: >-
          {{ (nexus_obj.networks.v4
              | selectattr('type','equalto','public')
              | map(attribute='ip_address')
              | list | first) | default('') }}

    - name: Validate we found public IPv4s
      ansible.builtin.assert:
        that:
          - jenkins_ip | length > 0
          - sonarqube_ip | length > 0
          - nexus_ip | length > 0
        fail_msg: "Could not determine one or more public IPs."

    - name: Show created IPs
      debug:
        msg:
          jenkins: "{{ jenkins_ip }}"
          sonarqube: "{{ sonarqube_ip }}"
          nexus: "{{ nexus_ip }}"

    # -------------------------
    # Add hosts for subsequent plays
    # -------------------------
    - name: Add Jenkins host
      add_host:
        name: jenkins
        ansible_host: "{{ jenkins_ip }}"
        groups: jenkins_group,created
        service_name: jenkins
        service_port: 8080
        domain: "{{ domains.jenkins }}"

    - name: Add SonarQube host
      add_host:
        name: sonarqube
        ansible_host: "{{ sonarqube_ip }}"
        groups: sonarqube_group,created
        service_name: sonarqube
        service_port: 9000
        domain: "{{ domains.sonarqube }}"

    - name: Add Nexus host
      add_host:
        name: nexus
        ansible_host: "{{ nexus_ip }}"
        groups: nexus_group,created
        service_name: nexus
        service_port: 8081
        domain: "{{ domains.nexus }}"

    # -------------------------
    # Optional post-create sleep (safe default)
    # -------------------------
    - name: Optional post-create sleep
      pause:
        seconds: "{{ post_create_wait_seconds | default(60) | int }}"
      when: (post_create_wait_seconds | default(60) | int) > 0

# -----------------------------------------
# Base OS & Docker/Nginx (common) on all servers
# -----------------------------------------
- name: Configure base packages (common) on all servers
  hosts: created
  become: true
  gather_facts: false
  serial: 1 # avoid apt lock contention
  pre_tasks:
    - name: Wait for SSH to be reachable (port 22)
      ansible.builtin.wait_for:
        host: "{{ ansible_host }}"
        port: 22
        delay: 5
        timeout: 900
      delegate_to: localhost

    - name: Wait for cloud-init to finish (if present)
      ansible.builtin.shell: |
        if command -v cloud-init >/dev/null 2>&1; then
          cloud-init status --wait
        else
          test -f /var/lib/cloud/instance/boot-finished || true
        fi
      register: cloudinit_status
      changed_when: false
      failed_when: false

    - name: Wait until no APT/Dpkg locks are held
      ansible.builtin.shell: |
        set -e
        for i in {1..60}; do
          if fuser /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/lib/apt/lists/lock >/dev/null 2>&1; then
            sleep 5
          elif pgrep -ax "apt|apt-get|unattended-upgrade|dpkg" >/dev/null 2>&1; then
            sleep 5
          else
            exit 0
          fi
        done
        echo "APT locks still present" >&2
        exit 1
      register: apt_locks
      changed_when: false

    - name: Gather facts
      ansible.builtin.setup:

  roles:
    - role: common # <- installs Docker, Nginx, Certbot, Portainer(9443), etc.

# -----------------------------------------
# App setup (HTTP-only, no TLS yet)
# -----------------------------------------

- name: Setup Jenkins (HTTP-only)
  hosts: jenkins_group
  become: true
  gather_facts: true
  pre_tasks:
    - name: Ensure Docker present (self-heal)
      ansible.builtin.shell: command -v docker
      register: has_docker_jenkins
      changed_when: false
      failed_when: false

    - name: Install Docker from common role if missing
      ansible.builtin.import_role:
        name: common
      when: has_docker_jenkins.rc != 0
  roles:
    - role: jenkins
  tags: [jenkins]

- name: Setup SonarQube (HTTP-only)
  hosts: sonarqube_group
  become: true
  gather_facts: true
  pre_tasks:
    - name: Ensure Docker present (self-heal)
      ansible.builtin.shell: command -v docker
      register: has_docker_sonar
      changed_when: false
      failed_when: false

    - name: Install Docker from common role if missing
      ansible.builtin.import_role:
        name: common
      when: has_docker_sonar.rc != 0
  roles:
    - role: sonarqube
  tags: [sonarqube]

- name: Setup Nexus (HTTP-only)
  hosts: nexus_group
  become: true
  gather_facts: true
  pre_tasks:
    - name: Ensure Docker present (self-heal)
      ansible.builtin.shell: command -v docker
      register: has_docker_nexus
      changed_when: false
      failed_when: false

    - name: Install Docker from common role if missing
      ansible.builtin.import_role:
        name: common
      when: has_docker_nexus.rc != 0
  roles:
    - role: nexus
  tags: [nexus]

# -----------------------------------------
# FINAL STAGE â€” Enable HTTPS & domain (last)
# -----------------------------------------
- name: Enable HTTPS & domain for Jenkins (LAST)
  hosts: jenkins_group
  become: true
  gather_facts: true
  pre_tasks:
    - name: DNS wait (seconds) before HTTPS
      pause:
        seconds: "{{ dns_wait_seconds | default(120) | int }}"
      when: (dns_wait_mode | default('prompt')) == 'seconds' and (dns_wait_seconds | default(0) | int) > 0
      run_once: true

    - name: DNS wait (prompt) before HTTPS
      pause:
        prompt: |
          Ensure DNS A record for {{ domain }} points to {{ ansible_default_ipv4.address | default(ansible_host) }} (Cloudflare: set 'DNS only' until first cert).
          Press Enter to continue with HTTPS enablement (Ctrl-C to abort)...
      when: (dns_wait_mode | default('prompt')) == 'prompt'
      run_once: true

    - name: Resolve domain to IPs on control machine (for precheck)
      ansible.builtin.command: bash -lc "getent ahostsv4 {{ domain }} | awk '{print $1}' | paste -sd ',' -"
      register: dns_resolve_j
      delegate_to: localhost
      changed_when: false
      failed_when: false
      run_once: true

    - name: Set resolved and expected IP facts
      set_fact:
        resolved_ips: "{{ dns_resolve_j.stdout | default('') }}"
        expected_ip: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      run_once: true

    - name: Fail if DNS does not resolve to this host (bypass with -e skip_dns_check=true)
      ansible.builtin.fail:
        msg: >-
          DNS for {{ domain }} is not pointing here yet (resolved: {{ resolved_ips }}, expected: {{ expected_ip }}).
          Update DNS at Cloudflare, wait, and re-run. Or bypass check with -e skip_dns_check=true
      when:
        - (skip_dns_check | default(false)) | bool == false
        - not (resolved_ips is search(expected_ip))
      run_once: true
  roles:
    - role: domain
  tags: [jenkins, https]

- name: Enable HTTPS & domain for SonarQube (LAST)
  hosts: sonarqube_group
  become: true
  gather_facts: true
  pre_tasks:
    - name: DNS wait (seconds) before HTTPS
      pause:
        seconds: "{{ dns_wait_seconds | default(120) | int }}"
      when: (dns_wait_mode | default('prompt')) == 'seconds' and (dns_wait_seconds | default(0) | int) > 0
      run_once: true

    - name: DNS wait (prompt) before HTTPS
      pause:
        prompt: |
          Ensure DNS A record for {{ domain }} points to {{ ansible_default_ipv4.address | default(ansible_host) }} (Cloudflare: set 'DNS only' until first cert).
          Press Enter to continue with HTTPS enablement (Ctrl-C to abort)...
      when: (dns_wait_mode | default('prompt')) == 'prompt'
      run_once: true

    - name: Resolve domain to IPs on control machine (for precheck)
      ansible.builtin.command: bash -lc "getent ahostsv4 {{ domain }} | awk '{print $1}' | paste -sd ',' -"
      register: dns_resolve_s
      delegate_to: localhost
      changed_when: false
      failed_when: false
      run_once: true

    - name: Set resolved and expected IP facts
      set_fact:
        resolved_ips: "{{ dns_resolve_s.stdout | default('') }}"
        expected_ip: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      run_once: true

    - name: Fail if DNS does not resolve to this host (bypass with -e skip_dns_check=true)
      ansible.builtin.fail:
        msg: >-
          DNS for {{ domain }} is not pointing here yet (resolved: {{ resolved_ips }}, expected: {{ expected_ip }}).
          Update DNS at Cloudflare, wait, and re-run. Or bypass check with -e skip_dns_check=true
      when:
        - (skip_dns_check | default(false)) | bool == false
        - not (resolved_ips is search(expected_ip))
      run_once: true
  roles:
    - role: domain
  tags: [sonarqube, https]

- name: Enable HTTPS & domain for Nexus (LAST)
  hosts: nexus_group
  become: true
  gather_facts: true
  pre_tasks:
    - name: DNS wait (seconds) before HTTPS
      pause:
        seconds: "{{ dns_wait_seconds | default(120) | int }}"
      when: (dns_wait_mode | default('prompt')) == 'seconds' and (dns_wait_seconds | default(0) | int) > 0
      run_once: true

    - name: DNS wait (prompt) before HTTPS
      pause:
        prompt: |
          Ensure DNS A record for {{ domain }} points to {{ ansible_default_ipv4.address | default(ansible_host) }} (Cloudflare: set 'DNS only' until first cert).
          Press Enter to continue with HTTPS enablement (Ctrl-C to abort)...
      when: (dns_wait_mode | default('prompt')) == 'prompt'
      run_once: true

    - name: Resolve domain to IPs on control machine (for precheck)
      ansible.builtin.command: bash -lc "getent ahostsv4 {{ domain }} | awk '{print $1}' | paste -sd ',' -"
      register: dns_resolve_n
      delegate_to: localhost
      changed_when: false
      failed_when: false
      run_once: true

    - name: Set resolved and expected IP facts
      set_fact:
        resolved_ips: "{{ dns_resolve_n.stdout | default('') }}"
        expected_ip: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      run_once: true

    - name: Fail if DNS does not resolve to this host (bypass with -e skip_dns_check=true)
      ansible.builtin.fail:
        msg: >-
          DNS for {{ domain }} is not pointing here yet (resolved: {{ resolved_ips }}, expected: {{ expected_ip }}).
          Update DNS at Cloudflare, wait, and re-run. Or bypass check with -e skip_dns_check=true
      when:
        - (skip_dns_check | default(false)) | bool == false
        - not (resolved_ips is search(expected_ip))
      run_once: true
  roles:
    - role: domain
  tags: [nexus, https]
